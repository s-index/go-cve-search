package nvd

import (
	"bytes"
	"compress/gzip"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"regexp"
	"strconv"
	"time"

	"github.com/s-index/go-cve-search/models"
)

const (
	nvdDataFeeds     = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-%s.json.gz"
	nvdDataFeedsMeta = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-%s.meta"
)

// FetchNVD get CVE info from NVD
func FetchNVD(cveID string) (cveItem models.CVEItem, err error) {

	var nvd models.NvdJSON
	year, err := CheckCveIDFormat(cveID)
	if err != nil {
		return cveItem, err
	}

	pwd := os.Getenv("PWD")
	nvd, err = UpdateNVD(pwd, year)
	if err != nil {
		return cveItem, err
	}

	for _, v := range nvd.CVEItems {
		if v.Cve.CVEDataMeta.ID == cveID {
			return v, nil
		}
	}
	return cveItem, errors.New("not get nvd data")
}

// CheckCveIDFormat check cveID format
func CheckCveIDFormat(cveID string) (year string, err error) {
	r := regexp.MustCompile(`^CVE-([0-9]{4})-[0-9]{4,}$`)
	if !r.MatchString(cveID) {
		return "", errors.New("not match cve format")
	}
	match := r.FindStringSubmatch(cveID)
	year = match[1]
	if year < "2002" || year > strconv.Itoa(time.Now().Year()) {
		return "", errors.New("not match cve format")
	}
	return year, nil
}

// UpdateNVD update nvd data & return NvdJSON
func UpdateNVD(pwd string, year string) (nvd models.NvdJSON, err error) {

	need, err := NeedNVDUpdate(pwd, year)
	if err != nil {
		return nvd, err
	}
	if need {
		nvd, err = FetchlNVD(pwd, year)
	} else {
		nvd, err = FetchLocalNVD(pwd, year)
	}
	return nvd, err
}

// NeedNVDUpdate check NVD meta
func NeedNVDUpdate(pwd string, year string) (bool, error) {
	const need, noNeed bool = true, false

	var emptyNvdMeta models.NvdMeta
	localNvdMeta, err := FetchLocalNVDMeta(pwd, year)
	if localNvdMeta == emptyNvdMeta && err == nil {
		return need, nil
	}

	nvdMeta, err := FetchNvdMeta(pwd, year)
	if err != nil {
		return noNeed, err
	}

	if nvdMeta.Sha256 == localNvdMeta.Sha256 {
		return noNeed, nil
	}
	return need, nil
}

// MkdirFeeds make feeds directory
func MkdirFeeds(pwd string) error {
	if _, err := os.Stat(pwd + "/feeds"); os.IsNotExist(err) {
		if err := os.Mkdir(pwd+"/feeds", 0700); err != nil {
			fmt.Println(err.Error())
			return err
		}
	}
	return nil
}

// FetchLocalNVD fetch pwd nvd data
func FetchLocalNVD(pwd string, year string) (nvd models.NvdJSON, err error) {

	raw, err := ioutil.ReadFile(fmt.Sprintf(pwd+"/feeds/%s.json", year))
	if err != nil {
		fmt.Println(err.Error())
		return nvd, err
	}
	json.Unmarshal(raw, &nvd)

	return nvd, nil
}

// FetchlNVD fetch pwd nvd data
func FetchlNVD(pwd string, year string) (nvd models.NvdJSON, err error) {

	MkdirFeeds(pwd)

	url := fmt.Sprintf(nvdDataFeeds, year)

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println(err.Error())
		return nvd, err
	}
	defer resp.Body.Close()

	byteArray, _ := ioutil.ReadAll(resp.Body)

	buffer := bytes.NewBuffer(byteArray)
	reader, _ := gzip.NewReader(buffer)
	output := bytes.Buffer{}
	output.ReadFrom(reader)
	raw := output.Bytes()

	file, err := os.Create(fmt.Sprintf(pwd+"/feeds/%s.json", year))
	if err != nil {
		fmt.Println(err.Error())
		return nvd, err
	}
	defer file.Close()

	file.Write(raw)
	json.Unmarshal(raw, &nvd)
	return nvd, nil

}

// FetchLocalNVDMeta fetch pwd nvd meta data
func FetchLocalNVDMeta(pwd string, year string) (models.NvdMeta, error) {

	var meta models.NvdMeta
	raw, err := ioutil.ReadFile(fmt.Sprintf(pwd+"/feeds/%s.meta", year))
	if err != nil {
		return meta, err
	}

	result := regexp.MustCompile("\r\n|\n\r|\n|\r").Split(string(raw), -1)
	meta.LastModifiedDate = regexp.MustCompile(":").Split(result[0], -1)[1]
	meta.Size = regexp.MustCompile(":").Split(result[1], -1)[1]
	meta.ZipSize = regexp.MustCompile(":").Split(result[2], -1)[1]
	meta.GzSize = regexp.MustCompile(":").Split(result[3], -1)[1]
	meta.Sha256 = regexp.MustCompile(":").Split(result[4], -1)[1]

	return meta, nil
}

// FetchNvdMeta fetch NVD meta data
func FetchNvdMeta(pwd string, year string) (models.NvdMeta, error) {

	var meta models.NvdMeta

	url := fmt.Sprintf(nvdDataFeedsMeta, year)

	resp, err := http.Get(url)
	if err != nil {
		fmt.Println(err.Error())
		return meta, err
	}
	defer resp.Body.Close()

	byteArray, _ := ioutil.ReadAll(resp.Body)

	err = MkdirFeeds(pwd)
	if err != nil {
		fmt.Println(err.Error())
		return meta, err
	}

	err = StoreNvdMeta(pwd, year, byteArray)
	if err != nil {
		return meta, err
	}

	meta = ConvertNvdMeta(byteArray)

	return meta, nil
}

// ConvertNvdMeta convert meta data to NvdMeta
func ConvertNvdMeta(meta []byte) models.NvdMeta {
	var metaModel models.NvdMeta

	result := regexp.MustCompile("\r\n|\n\r|\n|\r").Split(string(meta), -1)
	metaModel.LastModifiedDate = regexp.MustCompile(":").Split(result[0], -1)[1]
	metaModel.Size = regexp.MustCompile(":").Split(result[1], -1)[1]
	metaModel.ZipSize = regexp.MustCompile(":").Split(result[2], -1)[1]
	metaModel.GzSize = regexp.MustCompile(":").Split(result[3], -1)[1]
	metaModel.Sha256 = regexp.MustCompile(":").Split(result[4], -1)[1]

	return metaModel
}

// StoreNvdMeta store meta data to feeds/
func StoreNvdMeta(pwd string, year string, meta []byte) error {
	file, err := os.Create(fmt.Sprintf(pwd+"/feeds/%s.meta", year))
	if err != nil {
		fmt.Println(err.Error())
		return err
	}
	defer file.Close()

	_, err = file.Write(meta)
	if err != nil {
		fmt.Println(err.Error())
		return err
	}
	return nil
}
